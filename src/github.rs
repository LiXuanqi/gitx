use octocrab::Octocrab;
use serde::{Deserialize, Serialize};
use std::env;
use git2::Repository;
use url::Url;
use crate::metadata::CommitMetadata;

/// GitHub repository information
#[derive(Debug, Clone)]
pub struct GitHubRepo {
    pub owner: String,
    pub name: String,
}

/// Information about a created/updated PR
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PRInfo {
    pub number: u64,
    pub url: String,
    pub title: String,
}

/// GitHub API client wrapper
pub struct GitHubClient {
    octocrab: Octocrab,
    repo: GitHubRepo,
}

impl GitHubClient {
    /// Create a new GitHub client
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        // Get GitHub token from environment
        let token = env::var("GITHUB_TOKEN")
            .map_err(|_| "GITHUB_TOKEN environment variable not set")?;
        
        // Initialize octocrab with token
        let octocrab = Octocrab::builder()
            .personal_token(token)
            .build()?;
        
        // Get repository info from git remote
        let repo = get_github_repo_from_remote()?;
        
        Ok(Self { octocrab, repo })
    }
    
    /// Create a new pull request
    pub async fn create_pr(
        &self,
        branch_name: &str,
        title: &str,
        body: &str,
        base_branch: &str,
    ) -> Result<PRInfo, Box<dyn std::error::Error>> {
        println!("Creating PR: {} -> {}", branch_name, base_branch);
        
        let pr = self
            .octocrab
            .pulls(&self.repo.owner, &self.repo.name)
            .create(title, branch_name, base_branch)
            .body(body)
            .send()
            .await?;
        
        Ok(PRInfo {
            number: pr.number,
            url: pr.html_url.map(|u| u.to_string()).unwrap_or_default(),
            title: pr.title.unwrap_or_default(),
        })
    }
    
    /// Update an existing pull request
    pub async fn update_pr(
        &self,
        pr_number: u64,
        title: Option<&str>,
        body: Option<&str>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        println!("Updating PR #{}", pr_number);
        
        let pulls = self.octocrab.pulls(&self.repo.owner, &self.repo.name);
        let mut update = pulls.update(pr_number);
        
        if let Some(title) = title {
            update = update.title(title);
        }
        
        if let Some(body) = body {
            update = update.body(body);
        }
        
        update.send().await?;
        
        Ok(())
    }
    
    /// Generate PR body content from commit metadata
    pub fn generate_pr_body(&self, metadata: &CommitMetadata, commit_message: &str) -> String {
        let mut body = String::new();
        
        // Add main commit message
        if commit_message.lines().count() > 1 {
            body.push_str("## Description\n\n");
            body.push_str(&commit_message.lines().skip(1).collect::<Vec<_>>().join("\n"));
            body.push_str("\n\n");
        }
        
        // Add incremental commits if any
        if !metadata.incremental_commits.is_empty() {
            body.push_str("## Updates\n\n");
            for (i, inc_commit) in metadata.incremental_commits.iter().enumerate() {
                body.push_str(&format!(
                    "{}. **{}** ({})\n   - {}\n",
                    i + 1,
                    format_commit_type(&inc_commit.commit_type),
                    inc_commit.created_at.format("%Y-%m-%d %H:%M UTC"),
                    inc_commit.message.lines().next().unwrap_or("")
                ));
            }
            body.push_str("\n");
        }
        
        // Add metadata footer
        body.push_str("---\n");
        body.push_str(&format!("*Generated by gitx - Branch: `{}`*\n", metadata.pr_branch_name));
        body.push_str(&format!("*Created: {}*\n", metadata.created_at.format("%Y-%m-%d %H:%M UTC")));
        if !metadata.incremental_commits.is_empty() {
            body.push_str(&format!("*Last updated: {}*\n", metadata.last_updated.format("%Y-%m-%d %H:%M UTC")));
        }
        
        body
    }
    
    /// Push branch to remote origin
    pub async fn push_branch(&self, branch_name: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("Pushing branch to origin: {}", branch_name);
        
        // Use git command to push the branch
        let output = tokio::process::Command::new("git")
            .args(&["push", "-u", "origin", branch_name])
            .output()
            .await?;
        
        if !output.status.success() {
            let error = String::from_utf8_lossy(&output.stderr);
            return Err(format!("Failed to push branch: {}", error).into());
        }
        
        Ok(())
    }
}

/// Extract GitHub repository info from git remote
fn get_github_repo_from_remote() -> Result<GitHubRepo, Box<dyn std::error::Error>> {
    let repo = Repository::open(".")?;
    let remote = repo.find_remote("origin")?;
    let url_str = remote.url().ok_or("No URL found for origin remote")?;
    
    // Parse different GitHub URL formats
    let (owner, name) = if url_str.starts_with("git@github.com:") {
        // SSH format: git@github.com:owner/repo.git
        let path = url_str.strip_prefix("git@github.com:").unwrap();
        let path = path.strip_suffix(".git").unwrap_or(path);
        let parts: Vec<&str> = path.split('/').collect();
        if parts.len() != 2 {
            return Err("Invalid GitHub SSH URL format".into());
        }
        (parts[0].to_string(), parts[1].to_string())
    } else {
        // HTTPS format: https://github.com/owner/repo.git
        let url = Url::parse(url_str)?;
        if url.host_str() != Some("github.com") {
            return Err("Remote is not a GitHub repository".into());
        }
        
        let path = url.path().trim_start_matches('/');
        let path = path.strip_suffix(".git").unwrap_or(path);
        let parts: Vec<&str> = path.split('/').collect();
        if parts.len() != 2 {
            return Err("Invalid GitHub URL format".into());
        }
        (parts[0].to_string(), parts[1].to_string())
    };
    
    Ok(GitHubRepo { owner, name })
}

/// Format commit type for display
fn format_commit_type(commit_type: &crate::metadata::IncrementalCommitType) -> &'static str {
    match commit_type {
        crate::metadata::IncrementalCommitType::AmendedCommit => "Amended",
        crate::metadata::IncrementalCommitType::AdditionalCommit => "Additional",
    }
}

/// Check if GitHub token is available
pub fn check_github_token() -> bool {
    env::var("GITHUB_TOKEN").is_ok()
}

/// GitHub PR status information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GitHubPRStatus {
    pub number: u64,
    pub state: String,       // "open", "closed", "merged"
    pub title: String,
    pub url: String,
    pub mergeable: Option<bool>,
    pub draft: bool,
}

impl GitHubClient {
    /// Get PR status from GitHub
    pub async fn get_pr_status(&self, pr_number: u64) -> Result<GitHubPRStatus, Box<dyn std::error::Error>> {
        let pr = self
            .octocrab
            .pulls(&self.repo.owner, &self.repo.name)
            .get(pr_number)
            .await?;
        
        Ok(GitHubPRStatus {
            number: pr.number,
            state: pr.state.map(|s| format!("{:?}", s).to_lowercase()).unwrap_or_default(),
            title: pr.title.unwrap_or_default(),
            url: pr.html_url.map(|u| u.to_string()).unwrap_or_default(),
            mergeable: pr.mergeable,
            draft: pr.draft.unwrap_or(false),
        })
    }

    /// Get multiple PR statuses efficiently
    pub async fn get_multiple_pr_statuses(&self, pr_numbers: &[u64]) -> Result<Vec<GitHubPRStatus>, Box<dyn std::error::Error>> {
        let mut statuses = Vec::new();
        
        // Note: In a production system, you'd want to batch these requests
        // For now, we'll do them sequentially to avoid rate limiting
        for &pr_number in pr_numbers {
            match self.get_pr_status(pr_number).await {
                Ok(status) => statuses.push(status),
                Err(e) => {
                    eprintln!("Warning: Failed to get status for PR #{}: {}", pr_number, e);
                }
            }
        }
        
        Ok(statuses)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_ssh_url() {
        // Mock the git repository URL parsing
        // In real test, you'd need to mock Repository::open
    }

    #[test]
    fn test_parse_https_url() {
        let url = "https://github.com/owner/repo.git";
        let parsed = Url::parse(url).unwrap();
        assert_eq!(parsed.host_str(), Some("github.com"));
        
        let path = parsed.path().trim_start_matches('/');
        let path = path.strip_suffix(".git").unwrap_or(path);
        let parts: Vec<&str> = path.split('/').collect();
        assert_eq!(parts, vec!["owner", "repo"]);
    }

    #[test]
    fn test_pr_body_generation() {
        use crate::metadata::{CommitMetadata, IncrementalCommitType};
        use chrono::Utc;
        
        let metadata = CommitMetadata::new_branch_created(
            "gitx/test/feature".to_string(),
            "abc123".to_string()
        ).add_incremental_commit(
            "def456".to_string(),
            "Fix issue with tests".to_string(),
            IncrementalCommitType::AmendedCommit
        );
        
        let commit_message = "Add new feature\n\nThis adds a really cool feature\nthat does amazing things.";
        
        // This test would need to be updated to work with the actual GitHubClient
        // For now, just verify the structure compiles
        assert!(!metadata.incremental_commits.is_empty());
    }
}